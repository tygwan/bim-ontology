# 프로젝트 회고 (Retrospective)

**프로젝트**: BIM Ontology v1.0
**기간**: 2026-02-03 (Phase 0~5 단일 일 완료)

---

## 잘된 점 (What went well)

### 1. 빠른 프로토타이핑
- Phase 0~5를 하루 만에 완료
- IFC 로딩 → RDF 변환 → API → 클라이언트 → 대시보드 → Docker 전체 파이프라인 구축

### 2. 데이터 문제 조기 발견 및 대응
- F-002 (Navisworks 타입 손실)를 Phase 0에서 발견하고 이름 기반 분류로 즉시 우회
- F-004 (GlobalId 없는 엔티티)를 Phase 1에서 발견하고 geometry 필터링으로 해결
- 기하 형상 제외 전략으로 1,700만 엔티티 → 4,000개로 실질적 변환 대상 축소

### 3. 테스트 주도 개발
- 91개 테스트, 85%+ 커버리지
- 각 Phase마다 테스트 작성 → 코드 품질 유지
- Codex CLI 교차 리뷰로 F-010, F-011 추가 발견

### 4. 점진적 아키텍처 결정
- AD-001: GraphDB 대신 rdflib 인메모리 (외부 의존성 최소화)
- AD-006: Apache Jena 대신 owlrl (Python 네이티브)
- AD-008: React 대신 vanilla JS SPA (빌드 불필요)
- 각 결정이 복잡도를 줄이고 개발 속도를 높임

---

## 개선할 점 (What could be improved)

### 1. rdflib 성능 한계
- 동시 10명 부하 시 복잡 쿼리 P95 > 2초
- 단일 스레드 GIL 제약
- **대응**: GraphDB/Fuseki 외부 스토어 연동 필요

### 2. 이름 기반 분류의 한계
- "Other" 카테고리 44% (1,720/3,911)
- Navisworks 내보내기 파일의 근본적 한계
- **대응**: 원본 Revit/ArchiCAD 모델에서 직접 내보내기, 또는 ML 기반 분류

### 3. 스트리밍 변환기 효과 미미
- 기하 형상 제외 후 실제 변환 대상이 ~4,000개로 적어 배치 처리 이점 없음
- 일반 변환(1.3s)이 스트리밍(2.9s)보다 빠름
- **교훈**: 데이터 특성 파악 후 최적화 전략 결정

### 4. 문서와 코드의 스펙 차이
- 초기 Phase 문서(SPEC, TASKS, CHECKLIST)가 이상적 스펙 기준
- 실제 구현은 데이터 특성에 맞게 적응적으로 변경 (GraphDB→rdflib, React→vanilla JS 등)
- **교훈**: 스펙 문서를 구현 후 업데이트하는 습관 필요

---

## 핵심 수치

| 항목 | 값 |
|------|-----|
| 총 테스트 | 91 |
| 커버리지 | 85% |
| Python 모듈 | 15+ |
| API 엔드포인트 | 10 |
| SPARQL 템플릿 | 10 |
| 발견된 이슈 | 11 (F-001~F-011) |
| 아키텍처 결정 | 9 (AD-001~AD-009) |
| IFC4 변환 시간 | 1.3초 |
| 캐시 속도 향상 | 14,869x |
| 추론 트리플 증가 | +66.7% |

---

## 다음 단계

1. **GraphDB/Fuseki 연동**: 동시성 및 대규모 데이터 지원
2. **ifcOWL 공식 온톨로지 통합**: 표준 호환성 강화
3. **다중 온톨로지 융합**: EurOTL, SSN 등 도메인 온톨로지 연결
4. **규정 자동 검증**: SHACL 기반 Code Compliance Checking
5. **3D 뷰어**: IFC.js / Three.js 기반 기하 시각화
